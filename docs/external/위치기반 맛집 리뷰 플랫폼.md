Next.js 풀스택 위치기반 맛집 리뷰 플랫폼: 네이버 지도 연동 최종 문서
작성일: 2025년 10월 22일
대상 프레임워크: Next.js 14+ (App Router), TypeScript
대상 API 버전: 네이버 지도 JavaScript API v3 (LTS), 네이버 Geocoding API v2 (LTS), 네이버 Local Search API v1 (LTS)

1. 연동할 수단 및 사용할 기능 확정
"위치기반 맛집 리뷰 플랫폼" 구현을 위해 필요한 주요 연동 수단은 API입니다. 네이버 지도 JavaScript API는 웹 기반 SDK의 형태로 동작하며, 나머지 기능들은 순수 API 호출을 통해 구현됩니다. Webhook은 현재 요구사항에서는 직접적으로 필요하지 않습니다.
연동 수단	사용할 기능	비고
네이버 지도 JavaScript API v3 (웹 SDK 역할)	- 지도 표시 및 초기화 <br> - 맛집 위치 마커 표시 <br> - 마커 클릭 시 정보창(InfoWindow)을 통한 맛집 상세 정보(주소, 전화번호 등) 표시 <br> - Geolocation API 연동을 통한 사용자 현재 위치 표시 <br> - 지도 이벤트 처리 (클릭, 드래그, 확대/축소 등) <br> - 사용자 정의 오버레이 (예: 폴리곤) 표시	클라이언트 사이드에서 직접 지도 렌더링 및 조작
네이버 Geocoding API v2 (NCP Maps)	- 주소를 위도/경도(좌표)로 변환 <br> - 중심 좌표 기반 근접 주소 검색 <br> - 행정동/법정동 필터링 <br> - 다국어 지원 (한/영)	서버 사이드(Next.js API Route) 호출 필수 (Client Secret 보안)
네이버 Reverse Geocoding API v2 (NCP Maps)	- 위도/경도를 주소로 변환 <br> - 지도 클릭 시 해당 위치의 주소 표시	서버 사이드(Next.js API Route) 호출 필수 (Client Secret 보안)
네이버 Local Search API v1 (네이버 개발자 센터)	- 사용자 위치 기반 주변 맛집 검색 및 정보 조회 <br> - 키워드(예: "강남역 맛집")를 이용한 장소 검색 및 정보 조회	서버 사이드(Next.js API Route) 호출 권장 (Client ID, Client Secret 보안) <br> NCP Maps API와 별도 발급 필요

2. 각 수단에 대한 설치/세팅 및 인증 정보 관리 방법
2.1. 네이버 지도 JavaScript API v3 (웹 SDK 역할)
설치/세팅 방법:
이 API는 별도의 npm 패키지 설치 없이 <script> 태그를 통해 로드됩니다.
Next.js 환경에서는 next/script 컴포넌트를 사용하여 최적화된 로딩을 구현합니다.
공식 문서: 네이버 지도 API v3 시작하기
코드 예시 (app/map/page.tsx 등 클라이언트 컴포넌트 내부):
code
Tsx
// app/map/page.tsx (클라이언트 컴포넌트)
'use client';
import Script from 'next/script';
// ... (생략)

export default function MapPage() {
  // ... (생략)
  return (
    <>
      <Script
        strategy="beforeInteractive" // 지도가 보여지기 전에 스크립트 로드
        src={`https://oapi.map.naver.com/openapi/v3/maps.js?ncpClientId=${process.env.NEXT_PUBLIC_NCP_MAPS_CLIENT_ID}&submodules=geocoder`}
        onLoad={handleOnLoad} // 스크립트 로드 완료 시 콜백 함수 호출
      />
      <div id="map" style={{ width: '100%', height: '500px' }}></div>
      {/* ... (생략) */}
    </>
  );
}
인증 정보 관리 방법:
발급: 네이버 클라우드 플랫폼(NCP) 콘솔에서 "Application" 등록 시 "Maps" 서비스를 선택하고, Client ID와 Client Secret을 발급받습니다. 웹 서비스 URL (예: http://localhost:3000, https://your-domain.com)을 반드시 등록해야 합니다.
세팅: 프로젝트 루트의 .env.local 파일에 다음과 같이 저장합니다. (NEXT_PUBLIC_ 접두사를 붙여 클라이언트 사이드 코드에서 접근 가능하게 합니다.)
code
Code
NEXT_PUBLIC_NCP_MAPS_CLIENT_ID=YOUR_NCP_MAPS_CLIENT_ID_HERE
보안: .env.local 파일은 .gitignore에 추가하여 Git 저장소에 포함되지 않도록 관리합니다.
참고: Dynamic Map은 클라이언트에서 직접 호출하므로 Client ID만 사용하며, Client Secret은 필요하지 않습니다.
2.2. 네이버 Geocoding API v2
설치/세팅 방법:
이 API는 서버 사이드에서 호출되므로, Next.js API Routes를 통해 구현합니다.
공식 문서: NCP Maps API - Geocoding
필요 패키지: API 호출을 위해 axios (또는 내장 fetch)를 설치합니다. (npm install axios)
인증 정보 관리 방법:
발급: 네이버 클라우드 플랫폼(NCP) 콘솔에서 "Application" 등록 시 "Maps" 서비스를 선택하고, Client ID와 Client Secret을 발급받습니다. (Dynamic Map과 동일한 Application 사용 가능)
세팅: 프로젝트 루트의 .env.local 파일에 다음과 같이 저장합니다.
code
Code
NCP_MAPS_CLIENT_ID=YOUR_NCP_MAPS_CLIENT_ID
NCP_MAPS_CLIENT_SECRET=YOUR_NCP_MAPS_CLIENT_SECRET
보안: Client Secret은 절대 클라이언트 사이드 코드에 노출되어서는 안 됩니다. NEXT_PUBLIC_ 접두사를 붙이지 않고, Next.js API Routes (서버 사이드)에서만 접근하도록 합니다. .env.local은 .gitignore에 포함합니다.
참고: NCP Maps API는 Geocoding, Reverse Geocoding, Static Map, Directions 등 모든 API에 동일한 인증 정보를 사용합니다.

2.3. 네이버 Reverse Geocoding API v2
설치/세팅 방법:
이 API는 서버 사이드에서 호출되므로, Next.js API Routes를 통해 구현합니다.
공식 문서: NCP Maps API - Reverse Geocoding
필요 패키지: API 호출을 위해 axios (또는 내장 fetch)를 설치합니다. (npm install axios)
인증 정보 관리 방법:
발급: Geocoding API와 동일한 NCP Maps Application의 Client ID와 Client Secret을 사용합니다.
세팅: Geocoding API와 동일한 환경 변수를 사용합니다 (NCP_MAPS_CLIENT_ID, NCP_MAPS_CLIENT_SECRET).
참고: Reverse Geocoding은 좌표를 주소로 변환하는 기능으로, 사용자가 지도에서 특정 위치를 클릭했을 때 해당 위치의 주소를 표시하는 데 유용합니다.

2.4. 네이버 Local Search API v1
설치/세팅 방법:
이 API도 서버 사이드에서 호출되므로, Next.js API Routes를 통해 구현합니다.
공식 문서: 네이버 개발자 센터 - Local Search API 가이드
필요 패키지: API 호출을 위해 axios (또는 내장 fetch)를 설치합니다. (npm install axios)
인증 정보 관리 방법:
발급: 네이버 개발자 센터(developers.naver.com)에서 "Application" > "애플리케이션 등록" 시 "검색" > "지역" API를 선택하고, Client ID와 Client Secret을 발급받습니다. 웹 서비스 URL을 반드시 등록해야 합니다.
세팅: 프로젝트 루트의 .env.local 파일에 다음과 같이 저장합니다.
code
Code
NAVER_LOCAL_SEARCH_CLIENT_ID=YOUR_NAVER_DEVELOPER_LOCAL_CLIENT_ID
NAVER_LOCAL_SEARCH_CLIENT_SECRET=YOUR_NAVER_DEVELOPER_LOCAL_CLIENT_SECRET
보안: Client Secret은 절대 클라이언트 사이드 코드에 노출되어서는 안 됩니다. NEXT_PUBLIC_ 접두사를 붙이지 않고, Next.js API Routes (서버 사이드)에서만 접근하도록 합니다. .env.local은 .gitignore에 포함합니다.
참고: Local Search API는 NCP Maps API가 아닌 네이버 개발자 센터에서 제공하는 별도의 API입니다.

3. 각 수단에 대한 호출 방법
3.1. 네이버 지도 JavaScript API v3 (웹 SDK 역할)
API 주소: https://oapi.map.naver.com/openapi/v3/maps.js (Client ID를 쿼리 파라미터로 포함)
호출 방법 (클라이언트 컴포넌트 app/map/page.tsx 예시):
code
Tsx
// app/map/page.tsx (일부 발췌)
'use client';
import Script from 'next/script';
import { useEffect, useRef, useState } from 'react';

// 네이버 지도 전역 객체 TypeScript 타입 선언
declare global {
  interface Window {
    naver: any;
  }
}

export default function MapPage() {
  const mapRef = useRef<naver.maps.Map | null>(null);
  const [mapLoaded, setMapLoaded] = useState(false);
  // ... (생략: restaurants 상태, searchTerm 상태 등)

  const handleOnLoad = () => {
    setMapLoaded(true);
    initMap(); // 스크립트 로드 완료 후 지도 초기화
  };

  const initMap = () => {
    if (typeof window.naver === 'undefined' || !window.naver.maps) {
      console.error('Naver Maps API is not loaded.');
      return;
    }

    const mapOptions = { /* ... 지도 옵션 설정 ... */ };
    const map = new window.naver.maps.Map('map', mapOptions);
    mapRef.current = map;

    // 사용자 현재 위치 가져오기 및 마커 표시
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(position => {
        const userLatLng = new window.naver.maps.LatLng(position.coords.latitude, position.coords.longitude);
        map.setCenter(userLatLng);
        new window.naver.maps.Marker({
          position: userLatLng, map: map, title: '내 위치' /* ... */
        });
        // 사용자 위치 기반 맛집 검색 트리거
        fetchRestaurants(searchTerm, position.coords.latitude, position.coords.longitude);
      }, error => { /* ... 에러 처리 ... */ });
    }

    // 맛집 마커 및 정보창 추가 (restaurants 상태 변경 시 useEffect에서 처리)
    // ... (생략)
  };

  useEffect(() => {
    if (!mapLoaded || !mapRef.current) return;
    // 기존 마커 제거 로직
    // restaurants 배열을 순회하며 마커 생성, 정보창 바인딩 로직
    // 지도 중심 및 줌 레벨 조정 로직
  }, [mapLoaded, restaurants]);

  // ... (검색 폼, UI 렌더링)
  return (
    <>
      <Script
        strategy="beforeInteractive"
        src={`https://oapi.map.naver.com/openapi/v3/maps.js?ncpClientId=${process.env.NEXT_PUBLIC_NAVER_MAPS_CLIENT_ID}&submodules=geocoder`}
        onLoad={handleOnLoad}
      />
      <div id="map" style={{ width: '100%', height: '500px' }}></div>
    </>
  );
}
3.2. 네이버 Geocoding API v2
API 주소: https://maps.apigw.ntruss.com/map-geocode/v2/geocode
사용할 엔드포인트: GET /map-geocode/v2/geocode (주소 -> 좌표 변환)

주요 파라미터:
- query (필수): 검색할 주소
- coordinate (선택): 검색 중심 좌표 (경도,위도) - 근접한 순으로 결과 표시
- filter (선택): 검색 결과 필터 (HCODE|BCODE) - 예: "HCODE@4113554500;4113555000"
- language (선택): 응답 언어 (kor | eng, 기본값: kor)
- page (선택): 페이지 번호 (기본값: 1)
- count (선택): 결과 개수 (1-100, 기본값: 10)

응답 구조:
- status: 응답 상태 ("OK" | "INVALID_REQUEST" | "SYSTEM_ERROR")
- meta: { totalCount, page, count }
- addresses: 주소 정보 배열
  - roadAddress: 도로명 주소
  - jibunAddress: 지번 주소
  - englishAddress: 영문 주소
  - x: 경도
  - y: 위도
  - distance: 중심 좌표로부터의 거리(m)
  - addressElements: 주소 구성 요소 배열 (SIDO, SIGUGUN, DONGMYUN, RI, ROAD_NAME, BUILDING_NUMBER, BUILDING_NAME, LAND_NUMBER, POSTAL_CODE)

호출 방법 (Next.js API Route app/api/geocode/route.ts 예시):
code
TypeScript
// app/api/geocode/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('query');
  const coordinate = searchParams.get('coordinate'); // 선택: "경도,위도"
  const language = searchParams.get('language') || 'kor';
  const page = searchParams.get('page') || '1';
  const count = searchParams.get('count') || '10';

  if (!query) {
    return NextResponse.json({ error: 'Query parameter is required.' }, { status: 400 });
  }

  try {
    const params: Record<string, string> = {
      query,
      language,
      page,
      count,
    };

    if (coordinate) {
      params.coordinate = coordinate;
    }

    const response = await axios.get(
      'https://maps.apigw.ntruss.com/map-geocode/v2/geocode',
      {
        params,
        headers: {
          'x-ncp-apigw-api-key-id': process.env.NCP_MAPS_CLIENT_ID,
          'x-ncp-apigw-api-key': process.env.NCP_MAPS_CLIENT_SECRET,
          'Accept': 'application/json',
        },
      }
    );

    // 응답 상태 확인
    if (response.data.status === 'OK' && response.data.addresses?.length > 0) {
      return NextResponse.json({
        status: 'OK',
        meta: response.data.meta,
        addresses: response.data.addresses,
      });
    } else if (response.data.status === 'INVALID_REQUEST') {
      return NextResponse.json({ error: 'Invalid request parameters.' }, { status: 400 });
    } else {
      return NextResponse.json({ error: 'Address not found.' }, { status: 404 });
    }
  } catch (error: any) {
    console.error('Error calling NCP Geocoding API:', error.response?.data || error.message);

    // NCP API 에러 코드 처리
    const status = error.response?.status;
    if (status === 401) {
      return NextResponse.json({ error: 'Authentication failed. Check API keys.' }, { status: 401 });
    } else if (status === 429) {
      return NextResponse.json({ error: 'Quota exceeded or rate limited.' }, { status: 429 });
    }

    return NextResponse.json({ error: 'Failed to fetch geocoding data.' }, { status: 500 });
  }
}
3.3. 네이버 Reverse Geocoding API v2
API 주소: https://maps.apigw.ntruss.com/map-reversegeocode/v2
사용할 엔드포인트: GET /map-reversegeocode/v2/gc (좌표 -> 주소 변환)

주요 파라미터:
- coords (필수): 좌표 (경도,위도) - 예: "127.1054328,37.3595963"
- orders (선택): 변환 작업 이름 (roadaddr,admcode,legalcode 등)
- output (선택): 출력 형식 (json | xml, 기본값: xml)

응답 구조:
- status: { code, name, message }
- results: 변환 결과 배열
  - region: 지역 정보 (area1~area4: 시/도, 시/구/군, 동/면/리 등)
  - land: 지번 정보
  - code: 법정동/행정동 코드

호출 방법 (Next.js API Route app/api/reverse-geocode/route.ts 예시):
code
TypeScript
// app/api/reverse-geocode/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const lat = searchParams.get('lat');
  const lng = searchParams.get('lng');
  const orders = searchParams.get('orders') || 'roadaddr';

  if (!lat || !lng) {
    return NextResponse.json({ error: 'Latitude and longitude are required.' }, { status: 400 });
  }

  try {
    const coords = `${lng},${lat}`; // 경도,위도 순서

    const response = await axios.get(
      'https://maps.apigw.ntruss.com/map-reversegeocode/v2/gc',
      {
        params: {
          coords,
          orders,
          output: 'json',
        },
        headers: {
          'x-ncp-apigw-api-key-id': process.env.NCP_MAPS_CLIENT_ID,
          'x-ncp-apigw-api-key': process.env.NCP_MAPS_CLIENT_SECRET,
          'Accept': 'application/json',
        },
      }
    );

    // 응답 상태 확인
    if (response.data.status?.code === 0 && response.data.results?.length > 0) {
      const result = response.data.results[0];
      return NextResponse.json({
        status: 'OK',
        address: result.region || result.land,
        results: response.data.results,
      });
    } else {
      return NextResponse.json({ error: 'Address not found for coordinates.' }, { status: 404 });
    }
  } catch (error: any) {
    console.error('Error calling NCP Reverse Geocoding API:', error.response?.data || error.message);

    const status = error.response?.status;
    if (status === 401) {
      return NextResponse.json({ error: 'Authentication failed. Check API keys.' }, { status: 401 });
    } else if (status === 429) {
      return NextResponse.json({ error: 'Quota exceeded or rate limited.' }, { status: 429 });
    }

    return NextResponse.json({ error: 'Failed to fetch reverse geocoding data.' }, { status: 500 });
  }
}

3.4. 네이버 Local Search API v1
API 주소: https://openapi.naver.com/v1/search/local.json
사용할 엔드포인트: GET /v1/search/local.json (키워드 또는 위치 기반 검색)
호출 방법 (Next.js API Route app/api/search-restaurants/route.ts 예시):
code
TypeScript
// app/api/search-restaurants/route.ts
import { NextResponse } from 'next/server';
import axios from 'axios';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('query');
  const lat = searchParams.get('lat');
  const lng = searchParams.get('lng');
  const radius = searchParams.get('radius') || '5000'; // 기본 반경 5km

  if (!query) {
    return NextResponse.json({ error: 'Query parameter is required.' }, { status: 400 });
  }

  try {
    const params: Record<string, any> = {
      query: query,
      display: 20, // 결과 개수
      sort: 'random', // 정렬 방식
    };

    if (lat && lng) {
      params.x = lng; // 네이버 Local Search API는 x가 경도
      params.y = lat; // y가 위도
      params.radius = parseInt(radius, 10);
    }

    const response = await axios.get(
      'https://openapi.naver.com/v1/search/local.json',
      {
        params,
        headers: {
          'X-Naver-Client-Id': process.env.NAVER_LOCAL_SEARCH_CLIENT_ID,
          'X-Naver-Client-Secret': process.env.NAVER_LOCAL_SEARCH_CLIENT_SECRET,
        },
      }
    );

    return NextResponse.json(response.data.items);
  } catch (error: any) {
    console.error('Error calling Naver Local Search API:', error.response?.data || error.message);
    return NextResponse.json({ error: 'Failed to fetch local search data.' }, { status: 500 });
  }
}
4. 종합 Step-by-Step 가이드 (Next.js 14+ App Router)
Next.js 프로젝트 생성 및 Axios 설치:
code
Bash
npx create-next-app@latest my-restaurant-review-app --typescript --eslint --tailwind --app
cd my-restaurant-review-app
npm install axios
API 키 발급:
NCP 콘솔: 네이버 지도 JavaScript API용 Client ID, Geocoding API용 Client ID/Client Secret 발급.
네이버 개발자 센터: Local Search API용 Client ID/Client Secret 발급.
각 API별로 필요한 서비스 URL 등록 (예: http://localhost:3000).
환경 변수 설정 (.env.local):
code
Env
# NCP Maps API (Dynamic Map, Geocoding, Reverse Geocoding 공통)
NEXT_PUBLIC_NCP_MAPS_CLIENT_ID=YOUR_NCP_MAPS_CLIENT_ID
NCP_MAPS_CLIENT_ID=YOUR_NCP_MAPS_CLIENT_ID
NCP_MAPS_CLIENT_SECRET=YOUR_NCP_MAPS_CLIENT_SECRET

# 네이버 개발자 센터 Local Search API (별도 발급)
NAVER_LOCAL_SEARCH_CLIENT_ID=YOUR_NAVER_DEVELOPER_LOCAL_CLIENT_ID
NAVER_LOCAL_SEARCH_CLIENT_SECRET=YOUR_NAVER_DEVELOPER_LOCAL_SECRET
.gitignore에 .env.local 추가 필수.
참고: NEXT_PUBLIC_NCP_MAPS_CLIENT_ID와 NCP_MAPS_CLIENT_ID는 동일한 값입니다. 클라이언트에서 사용할 때는 NEXT_PUBLIC_ 접두사를 사용하고, 서버에서 참조할 때는 NCP_MAPS_CLIENT_ID를 사용합니다.
지도 표시 클라이언트 컴포넌트 생성 (app/map/page.tsx):
'use client' 지시자를 포함하여 클라이언트 컴포넌트로 정의.
next/script를 사용하여 네이버 지도 JavaScript API 로드 (ncpClientId 포함).
initMap 함수 내에서 window.naver.maps 객체를 사용하여 지도 초기화 및 Geolocation API 연동.
useEffect 훅을 사용하여 restaurants 상태 변화에 따라 지도에 마커를 추가/제거하는 로직 구현.
declare global { interface Window { naver: any; } } 추가.
API Routes 구현:
다음 API Route 파일들을 생성합니다:
- app/api/geocode/route.ts: 주소 → 좌표 변환 (Geocoding API)
- app/api/reverse-geocode/route.ts: 좌표 → 주소 변환 (Reverse Geocoding API)
- app/api/search-restaurants/route.ts: 맛집 검색 (Local Search API)
각 파일에서 환경 변수 (process.env.NCP_MAPS_CLIENT_ID 등)를 사용하여 인증 정보를 안전하게 전달합니다.
클라이언트로부터 받은 쿼리 파라미터를 사용하여 API 호출을 수행하고, 결과를 클라이언트에 JSON 형태로 반환합니다.
에러 처리는 NCP API의 상태 코드 (401, 429, 500 등)를 고려하여 구현합니다.
애플리케이션 실행 및 테스트:
code
Bash
npm run dev
브라우저에서 http://localhost:3000/map으로 접속합니다.
브라우저의 위치 정보 접근 권한 요청 시 허용합니다.
지도 표시, 사용자 위치 표시, 검색창을 통한 맛집 검색 및 마커 표시, 마커 클릭 시 정보창 표시 등의 기능이 정상적으로 작동하는지 확인합니다.